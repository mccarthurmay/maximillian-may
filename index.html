<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planet Portfolio - Prototype</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            display: none;
        }
        #coordinates {
            display: none;
        }
        #spotify-player {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 250px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        #spotify-player.minimized {
            width: 40px;
            height: 40px;
            padding: 0;
            background: transparent;
            backdrop-filter: none;
            overflow: hidden;
        }
        #spotify-toggle {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 30px;
            height: 30px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 0, 0, 0.8);
            border-radius: 6px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: background 0.2s;
        }
        #spotify-toggle:hover {
            background: rgba(0, 0, 0, 0.8);
        }
        #spotify-iframe {
            transition: opacity 0.3s ease;
        }
        #spotify-player.minimized #spotify-iframe {
            opacity: 0;
            pointer-events: none;
        }
        .sign-label {
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            font-family: Arial, sans-serif;
            border: 1px solid rgba(255, 255, 255, 0.3);
            pointer-events: none;
            white-space: normal;
            max-width: 300px;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>Controls:</strong><br>
        W - Move forward<br>
        S - Move backward<br>
        A - Turn left<br>
        D - Turn right<br>
        SPACE - Jump<br>
        Middle Mouse - Bird's Eye View<br>
        Scroll - Zoom (bird's eye)<br>
        R - Return to player<br>
        <br>
        <span id="camera-mode-text">Walk around the planet!</span>
    </div>

    <div id="coordinates">
        Position: (0, 0, 0)
    </div>

    <div id="quality-indicator" style="position: fixed; top: 130px; left: 10px; color: rgba(255, 255, 255, 0.7); font-family: 'Courier New', monospace; font-size: 12px; z-index: 1000; background: rgba(0, 0, 0, 0.3); padding: 5px 10px; border-radius: 5px;">
        Quality: Auto (Ultra)
    </div>

    <!-- Escape Menu -->
    <div id="menu-overlay"></div>
    <div id="escape-menu">
        <h2>Settings</h2>

        <div class="menu-option">
            <h3>Graphics Quality</h3>
            <p>Adjust visual quality for better performance or visuals</p>
            <button class="menu-button" id="quality-cycle-btn">
                <span id="quality-mode-text">Auto</span>
                <span class="current-value" id="quality-tier-text">Ultra</span>
            </button>
        </div>

        <div class="menu-option">
            <h3>Time of Day</h3>
            <p>Control the sun/moon position and day/night cycle</p>
            <div style="display: flex; align-items: center; gap: 15px; margin-top: 10px;">
                <span style="color: rgba(255, 255, 255, 0.7); min-width: 60px;">Night</span>
                <input type="range" id="time-slider" min="0" max="100" value="50" class="time-slider">
                <span style="color: rgba(255, 255, 255, 0.7); min-width: 60px;">Day</span>
            </div>
            <div style="text-align: center; margin-top: 10px;">
                <button class="menu-button" id="time-auto-btn" style="font-size: 0.9em; padding: 8px 15px;">
                    <span id="time-mode-text">Auto Cycle</span>
                </button>
            </div>
        </div>

        <div class="menu-close-hint">Press ESC to close</div>
    </div>

    <div id="spotify-player">
        <button id="spotify-toggle" onclick="toggleSpotify(event)">âˆ’</button>
        <iframe id="spotify-iframe" style="border-radius:12px"
                width="100%"
                height="180"
                scrolling="no"
                frameBorder="0"
                allow="autoplay"
                src="https://w.soundcloud.com/player/?url=https%3A//soundcloud.com/vinceguaraldiquintet/sets/a-charlie-brown-thanksgiving&color=%23000000&auto_play=false&hide_related=false&show_comments=false&show_user=true&show_reposts=false&show_teaser=false">
        </iframe>
    </div>

    <div id="loading-screen">
        <div id="loading-content">
            <h1>Max's World</h1>
            <div id="loading-bar-container">
                <div id="loading-bar"></div>
            </div>
            <p id="loading-text">Loading... 0%</p>
            <div id="controls-info">
                <h3>Controls</h3>
                <p><strong>WASD</strong> - Move</p>
                <p><strong>Space</strong> - Jump</p>
                <p><strong>Mouse</strong> - Look around</p>
                <p><strong>Scroll Wheel</strong> - Zoom in/out</p>
                <p><strong>F</strong> - Toggle bird's eye view</p>
                <p><strong>X</strong> - Reset to spawn</p>
            </div>
        </div>
    </div>

    <div id="intro-screen">
        <div id="intro-content">
            <h1>Max's World</h1>
            <p id="enter-prompt">Press ENTER to begin</p>
        </div>
    </div>

    <style>
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            transition: opacity 1s ease-out;
        }

        #loading-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        #loading-content {
            text-align: center;
            color: white;
            max-width: 600px;
        }

        #loading-content h1 {
            font-size: 4em;
            margin-bottom: 40px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        #loading-bar-container {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        #loading-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        #loading-text {
            font-size: 1.2em;
            margin-bottom: 40px;
            color: rgba(255, 255, 255, 0.7);
        }

        #controls-info {
            margin-top: 40px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #controls-info h3 {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #8BC34A;
        }

        #controls-info p {
            font-size: 1.1em;
            margin: 10px 0;
            color: rgba(255, 255, 255, 0.8);
        }

        #controls-info strong {
            color: white;
            min-width: 120px;
            display: inline-block;
        }

        #intro-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 999;
            opacity: 0;
            transition: opacity 1s ease-out;
        }

        #intro-screen.visible {
            opacity: 1;
        }

        #intro-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        #intro-content {
            text-align: center;
            color: white;
        }

        #intro-content h1 {
            font-size: 4em;
            margin-bottom: 30px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 5px;
        }

        #enter-prompt {
            font-size: 1.5em;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Escape Menu Styles */
        #escape-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            background: rgba(20, 20, 30, 0.95);
            border: 2px solid rgba(139, 195, 74, 0.5);
            border-radius: 15px;
            padding: 30px;
            z-index: 9999;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
        }

        #escape-menu.visible {
            display: block;
        }

        #escape-menu h2 {
            margin: 0 0 30px 0;
            color: #8BC34A;
            font-size: 2em;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .menu-option {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .menu-option:hover {
            background: rgba(139, 195, 74, 0.1);
            border-color: rgba(139, 195, 74, 0.5);
            transform: translateX(5px);
        }

        .menu-option h3 {
            margin: 0 0 10px 0;
            color: white;
            font-size: 1.3em;
        }

        .menu-option p {
            margin: 0 0 15px 0;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.95em;
        }

        .menu-button {
            background: rgba(139, 195, 74, 0.8);
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            color: white;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .menu-button:hover {
            background: rgba(139, 195, 74, 1);
            transform: scale(1.05);
        }

        .menu-button:active {
            transform: scale(0.95);
        }

        .current-value {
            display: inline-block;
            background: rgba(139, 195, 74, 0.3);
            padding: 5px 15px;
            border-radius: 5px;
            margin-left: 10px;
            color: #8BC34A;
            font-weight: bold;
        }

        #menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9998;
            display: none;
        }

        #menu-overlay.visible {
            display: block;
        }

        .menu-close-hint {
            text-align: center;
            margin-top: 20px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9em;
        }

        /* Time of Day Slider */
        .time-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: linear-gradient(to right, #1a1a2e 0%, #8BC34A 50%, #ffd700 100%);
            border-radius: 5px;
            outline: none;
            cursor: pointer;
        }

        .time-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: white;
            border: 2px solid #8BC34A;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .time-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            background: #8BC34A;
        }

        .time-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: white;
            border: 2px solid #8BC34A;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .time-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            background: #8BC34A;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);
        scene.fog = new THREE.Fog(0x0a0a1a, 20, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // CSS2D Renderer for sign labels
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x808080, 3.0); // Increased for brighter nighttime
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 3.0); // Increased from 2.0 to 3.0 for brighter sunlight
        sunLight.position.set(10, 10, 10);
        sunLight.castShadow = true;
        sunLight.shadow.camera.left = -30;
        sunLight.shadow.camera.right = 30;
        sunLight.shadow.camera.top = 30;
        sunLight.shadow.camera.bottom = -30;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 150;
        sunLight.shadow.mapSize.width = 8192;
        sunLight.shadow.mapSize.height = 8192;
        sunLight.shadow.bias = -0.0001; // Reduced bias for tighter contact shadows
        sunLight.shadow.normalBias = 0.02; // Increased to prevent self-shadowing artifacts
        sunLight.shadow.radius = 2; // Slightly softer shadows

        // Planet
        const planetRadius = 16;

        const planetGroup = new THREE.Group();
        planetGroup.add(sunLight);
        scene.add(planetGroup);

        // Store sign labels and their world positions for proximity detection
        const signLabels = [];

        // Store spawn cube reference
        let spawnCube = null;

        // Bird's eye camera controls
        let detachedCamera = false;
        let birdEyeDistance = 25; // Distance from origin in bird's eye view
        let birdEyeTilt = Math.PI / 6; // 30 degree tilt from top-down (0 = straight down, PI/2 = horizontal)
        let birdEyeRotation = new THREE.Quaternion(); // Independent rotation for bird's eye view
        let isDragging = false;

        // Saved state for returning from bird's eye view
        let savedPlanetRotation = new THREE.Quaternion();
        let savedCharacterRotation = 0;
        let savedCharacterPosition = new THREE.Vector3();

        // Sign content data
        const signData = {
            'sign1': 'Press enter to teleport back to your crash landing.',
            'sign2': 'These were the base for me to grow my creative interests...',
            'sign3': 'Walk left to know my story, right for (the start of) my professional journey.', // second
            'sign4': 'Other interests/hobbies.',
            'sign5': 'This way to see my hobbies/passions.',
            'sign6': 'Then, I started exploring the adirondacks.',
            "sign7": "WASD to move. Space to jump.", // Start sign
            'sign8': 'I was born in Guangzhou, China. I only lived there for a short 5 years. We left for the US, my mom making a new life and my dad returning home.', // third
            'sign9': 'I had a great time growing up. Timeless memories were made with the friends I met, and now a few will remain life-long.', // left 2
            'sign10': 'Then, I took a leap of faith going to Colorado College, a small liberal arts school in Colorado Springs. I\'m grateful for who I am today, and it\'s safe to say that these past 3 years have been incredibly transformative. I wouldn\'t be who I am today if not for the people I surrounded myself with and the passions I chose to pursue.', // left three
            'sign11': 'I am now a junior.',
            'sign12': "I'm currently doing research for a professor at the Colorado School of Mines regarding the stigma around mental health.",
            'sign13': "Here's a list of my project: Super mario A* and Theta* Pathfinder in C, Top-Down Adventure Game in Java, Stock Tracker using Alpaca. (a gallery area)",
            'sign14': 'Dabbling in Cybersecurity: Certification in eJPT, working on the PNPT.',
            'sign15': 'Future projects: TBD',
            'sign16': '1',
            'sign17': '2',
            'sign18': '3',
            'sign19': '4',
            'sign20': 'My love of the outdoors started with kayaking the lakes of NY.',
            'sign21': 'Click the sign to see photography portfolio.',
            'sign22': 'Click the sign to see my videography portfolio.',
            'sign23': 'Thank You for Visiting!',
            'sign24': 'Esc for pause menu. ',
            'sign25': 'F to toggle bird\'s eye view. Left click & drag to rotate. Scroll wheel to zoom.',
            'sign26': 'X to reset entirely if you\'re in a pickle.'
        };

        // Load the Blender world model
        const planetLoader = new GLTFLoader();
        planetLoader.load('world-only.glb',
            // onLoad callback
            function(gltf) {
            const planet = gltf.scene;

            planet.traverse((child) => {
                if (child.isMesh) {
                    const name = child.name.toLowerCase();
                    const isGround = name.includes('ground');

                    child.castShadow = !isGround;
                    child.receiveShadow = true;

                    // Log all meshes to help debug spawn detection
                    if (name.includes('spawn')) {
                        console.log(`>>> SPAWN MESH FOUND: "${child.name}" (lowercase: "${name}")`);
                    }

                    // Check if this is the spawn cube (check exact name or contains 'spawn')
                    if (name === 'spawn' || name.includes('spawn')) {
                        spawnCube = child;
                        console.log(`Found spawn cube: "${child.name}" (original: "${child.name}") at local position:`, child.position);
                    }

                    // Check if this is a sign
                    if (child.name.toLowerCase().includes('sign')) {
                        const signName = child.name.toLowerCase();
                        const signText = signData[signName];

                        // Only create label if sign has text defined
                        if (signText) {
                            // Create label div
                            const labelDiv = document.createElement('div');
                            labelDiv.className = 'sign-label';
                            labelDiv.textContent = signText;

                            // Create CSS2DObject
                            const label = new CSS2DObject(labelDiv);
                            label.visible = false; // Hidden by default

                            // Get world position of the sign for proximity checking
                            child.updateWorldMatrix(true, false);
                            const signWorldPos = new THREE.Vector3();
                            child.getWorldPosition(signWorldPos);

                            // Position label directly on the sign (centered on the mesh)
                            label.position.set(0, -15, 0);
                            child.add(label);

                            // Store reference for proximity checking
                            signLabels.push({
                                labelObject: label,
                                mesh: child,
                                worldPos: signWorldPos
                            });

                            console.log(`Created label for ${child.name}: "${signText}"`);
                        } else {
                            console.log(`Skipped label for ${child.name}: no text defined`);
                        }
                    }
                }
            });

            planetGroup.add(planet);
            console.log('Blender world model loaded successfully');

            // Build collision meshes array for physics
            buildCollisionMeshes();
            console.log(`Built collision meshes array: ${collisionMeshes.length} meshes`);

            // Rotate planet so spawn cube is at character position (0, y, 0)
            console.log('Checking for spawn cube...', spawnCube ? 'Found!' : 'Not found');
            if (spawnCube) {
                // Get the spawn cube's position within the planet's local coordinate system
                // We need to traverse up to find the position in planet's space
                let spawnLocalPos = new THREE.Vector3();
                spawnCube.getWorldPosition(spawnLocalPos);

                // Convert world position to planet's local space
                const planetWorldToLocal = new THREE.Matrix4();
                planetWorldToLocal.copy(planetGroup.matrixWorld).invert();
                spawnLocalPos.applyMatrix4(planetWorldToLocal);

                console.log(`Spawn cube position in planet space: (${spawnLocalPos.x.toFixed(2)}, ${spawnLocalPos.y.toFixed(2)}, ${spawnLocalPos.z.toFixed(2)})`);

                // Normalize the position to get direction on the sphere surface
                const spawnDirection = spawnLocalPos.clone().normalize();

                // We want this direction to point "up" (0, 1, 0) after rotation
                // Calculate the rotation needed
                const upVector = new THREE.Vector3(0, 1, 0);
                const rotationAxis = new THREE.Vector3().crossVectors(spawnDirection, upVector).normalize();
                const rotationAngle = Math.acos(spawnDirection.dot(upVector));

                console.log(`Rotation angle: ${(rotationAngle * 180 / Math.PI).toFixed(2)} degrees`);
                console.log(`Rotation axis: (${rotationAxis.x.toFixed(2)}, ${rotationAxis.y.toFixed(2)}, ${rotationAxis.z.toFixed(2)})`);

                // Apply the rotation
                const spawnRotation = new THREE.Quaternion();
                spawnRotation.setFromAxisAngle(rotationAxis, rotationAngle);
                planetGroup.quaternion.copy(spawnRotation);

                // Update matrices
                planetGroup.updateMatrixWorld(true);

                // Get spawn position for character height
                spawnCube.geometry.computeBoundingBox();
                const bbox = spawnCube.geometry.boundingBox;
                const cubeHeight = bbox.max.y - bbox.min.y;

                // Character height should be at the planet radius + spawn offset
                const spawnHeight = spawnLocalPos.length();
                const spawnY = spawnHeight + cubeHeight / 2 + 3.0;
                characterGroup.position.set(0, spawnY, 0);

                // Store spawn state globally for reset
                window.initialSpawnRotation = spawnRotation.clone();
                window.initialSpawnY = spawnY;

                console.log(`Character spawned at height: ${characterGroup.position.y.toFixed(2)}`);
            }

            // Hide loading screen and show intro screen after world is loaded
            const loadingScreen = document.getElementById('loading-screen');
            const introScreen = document.getElementById('intro-screen');

            // Show intro screen immediately, then fade out loading screen
            introScreen.classList.add('visible');
            loadingScreen.classList.add('fade-out');
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 1000);
        },
        // onProgress callback
        function(xhr) {
            const loadingBar = document.getElementById('loading-bar');
            const loadingText = document.getElementById('loading-text');

            if (xhr.lengthComputable) {
                const percentComplete = (xhr.loaded / xhr.total) * 100;
                loadingBar.style.width = percentComplete + '%';
                loadingText.textContent = `Loading... ${Math.round(percentComplete)}%`;
                console.log(`Loading: ${Math.round(percentComplete)}% (${xhr.loaded}/${xhr.total} bytes)`);
            } else {
                // If not computable, show a loading animation instead
                const mb = (xhr.loaded / 1024 / 1024).toFixed(2);
                loadingText.textContent = `Loading... ${mb} MB`;
                console.log(`Loading: ${mb} MB (total size unknown)`);
                // Animate bar in indeterminate mode
                loadingBar.style.width = '50%';
            }
        },
        // onError callback
        function(error) {
            console.error('Error loading world model:', error);
            const loadingText = document.getElementById('loading-text');
            loadingText.textContent = 'Error loading world. Please refresh.';
            loadingText.style.color = '#ff5555';
        });

        // Character setup
        const characterGroup = new THREE.Group();
        scene.add(characterGroup);

        // Animation mixer and actions
        let mixer = null;
        let walkAction = null;
        let idleAction = null;
        let jumpAction = null;
        let characterModel = null;
        let characterLoaded = false;

        // Animation state
        const animationState = {
            isWalking: false,
            isJumping: false
        };

        // Load penguin character model
        const characterLoader = new GLTFLoader();
        characterLoader.load('manchot_the_penguin.glb', 
            function(gltf) {
                console.log('Penguin character loaded successfully!');
                characterModel = gltf.scene;
                
                // Scale the penguin to appropriate size
                characterModel.scale.set(0.075, 0.075, 0.075);
                
                // Enable shadows
                characterModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                characterGroup.add(characterModel);
                
                // Setup animation mixer
                if (gltf.animations && gltf.animations.length > 0) {
                    console.log('Found animations:', gltf.animations.map(a => a.name));
                    
                    mixer = new THREE.AnimationMixer(characterModel);
                    
                    // Try to find walk animation
                    const walkAnim = gltf.animations.find(a => 
                        a.name.toLowerCase().includes('walk') || 
                        a.name.toLowerCase().includes('run') ||
                        a.name.toLowerCase().includes('waddle')
                    ) || gltf.animations[0]; // Fallback to first animation
                    
                    // Try to find idle animation
                    const idleAnim = gltf.animations.find(a =>
                        a.name.toLowerCase().includes('idle') ||
                        a.name.toLowerCase().includes('standing')
                    );

                    // Try to find jump animation
                    const jumpAnim = gltf.animations.find(a =>
                        a.name.toLowerCase().includes('jump') ||
                        a.name.toLowerCase().includes('hop')
                    );

                    if (walkAnim) {
                        walkAction = mixer.clipAction(walkAnim);
                        walkAction.setEffectiveTimeScale(1.2); // Speed up animation
                        console.log('Walk animation set:', walkAnim.name);
                    }

                    if (idleAnim) {
                        idleAction = mixer.clipAction(idleAnim);
                        idleAction.play();
                        console.log('Idle animation set:', idleAnim.name);
                    } else if (walkAction) {
                        // If no idle, just stop walk animation when not moving
                        console.log('No idle animation found, using walk animation only');
                    }

                    if (jumpAnim) {
                        jumpAction = mixer.clipAction(jumpAnim);
                        jumpAction.setLoop(THREE.LoopOnce); // Play once per jump
                        jumpAction.clampWhenFinished = true; // Hold last frame
                        jumpAction.setEffectiveTimeScale(1.5); // Play 1x faster
                        console.log('Jump animation set:', jumpAnim.name);
                    }
                } else {
                    console.warn('No animations found in penguin model');
                }
                
                characterLoaded = true;
                console.log('Penguin character setup complete');
            }, 
            function(progress) {
                console.log('Loading penguin:', (progress.loaded / progress.total * 100).toFixed(2) + '%');
            },
            function(error) {
                console.error('Error loading penguin model:', error);
            }
        );

        // Position character at spawn height
        const characterHeight = 0.075;
        const spawnHeight = 13; // Spawn higher to ensure proper ground detection
        characterGroup.position.set(0, spawnHeight, 0);

        // Stars background
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.1,
            transparent: true,
            opacity: 1.0,
            depthWrite: false
        });
        const starsVertices = [];
        for (let i = 0; i < 1000; i++) {
            const x = (Math.random() - 0.5) * 100;
            const y = (Math.random() - 0.5) * 100;
            const z = (Math.random() - 0.5) * 100;
            starsVertices.push(x, y, z);
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        planetGroup.add(stars);

        // Atmosphere
        const atmosphereGeometry = new THREE.SphereGeometry(25, 32, 32);
        const atmosphereMaterial = new THREE.ShaderMaterial({
            uniforms: {
                sunDirection: { value: new THREE.Vector3(1, 1, 1).normalize() },
                dayColor: { value: new THREE.Color(0x87CEEB) },
                nightColor: { value: new THREE.Color(0x000000) },
                horizonColor: { value: new THREE.Color(0xFF8C00) }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 sunDirection;
                uniform vec3 dayColor;
                uniform vec3 nightColor;
                uniform vec3 horizonColor;
                varying vec3 vNormal;
                varying vec3 vPosition;

                void main() {
                    vec3 normal = normalize(vPosition);
                    float sunAlignment = dot(normal, sunDirection);
                    float dayStrength = smoothstep(-0.3, 0.3, sunAlignment);

                    // More realistic horizon gradient - based on viewing angle
                    float horizonFade = abs(normal.y); // 0 at horizon, 1 at zenith/nadir
                    horizonFade = pow(horizonFade, 0.6); // Gentle curve for atmospheric depth

                    // Only show orange horizon during sunrise/sunset (transition periods)
                    // When dayStrength is 0.5, we're at the horizon line (sun rising/setting)
                    float transitionStrength = 1.0 - abs(dayStrength - 0.5) * 2.0; // 1.0 at sunset/sunrise, 0.0 at full day/night
                    transitionStrength = smoothstep(0.0, 0.5, transitionStrength); // Smooth the transition

                    // Horizon glow around sun (only during transitions)
                    float horizonGlow = 1.0 - abs(sunAlignment);
                    horizonGlow = pow(horizonGlow, 2.0) * transitionStrength * (1.0 - horizonFade * 0.7);

                    // Sky gradient from horizon to zenith
                    vec3 zenithColor = dayColor;
                    vec3 horizonSkyColor = mix(horizonColor, dayColor, 0.3 + (1.0 - transitionStrength) * 0.7); // Less orange during full day
                    vec3 skyColor = mix(horizonSkyColor, zenithColor, horizonFade);

                    // Blend with night
                    skyColor = mix(nightColor, skyColor, dayStrength);

                    // Add warm glow near horizon where sun is (only during transitions)
                    skyColor = mix(skyColor, horizonColor, horizonGlow * 0.6);

                    // Add sun disc directly to the atmosphere
                    float sunProximity = max(0.0, sunAlignment);
                    float sunDisc = pow(sunProximity, 150.0); // Sharp disc
                    vec3 sunColor = vec3(1.0, 0.95, 0.8); // Warm yellow-white sun
                    skyColor = mix(skyColor, sunColor, sunDisc * dayStrength);

                    // Fully opaque atmosphere
                    float alpha = dayStrength * 0.9 + 0.1;

                    gl_FragColor = vec4(skyColor, alpha);
                }
            `,
            side: THREE.BackSide,
            transparent: true,
            depthWrite: false
        });
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        scene.add(atmosphere);

        // Low Poly Clouds
        // Create a single low poly cloud geometry
        function createLowPolyCloud() {
            const cloud = new THREE.Group();

            // Create 3-7 spheres with low poly count for puffy cloud look
            const numPuffs = 3 + Math.floor(Math.random() * 5);

            // Random cloud width factor
            const widthFactor = 0.5 + Math.random() * 1.5; // 0.5 to 2.0x width

            for (let i = 0; i < numPuffs; i++) {
                const puffGeometry = new THREE.SphereGeometry(
                    0.3 + Math.random() * 0.5, // Random size between 0.3 and 0.8
                    6, // Low poly - 6 segments
                    5  // Low poly - 5 segments
                );

                const puffMaterial = new THREE.MeshLambertMaterial({
                    color: 0xffffff,
                    flatShading: true // Emphasize low poly look
                });

                const puff = new THREE.Mesh(puffGeometry, puffMaterial);

                // Position puffs to create cloud shape with variable width
                puff.position.x = (Math.random() - 0.5) * 1.5 * widthFactor; // Wider spread
                puff.position.y = (Math.random() - 0.5) * 0.5; // Keep height variation smaller
                puff.position.z = (Math.random() - 0.5) * 1.5 * widthFactor; // Wider spread

                cloud.add(puff);
            }

            return cloud;
        }

        // Generate multiple clouds around the planet
        const clouds = [];
        const numClouds = 150;

        for (let i = 0; i < numClouds; i++) {
            const cloud = createLowPolyCloud();

            // Variable distance from planet - creates layered cloud effect
            const baseDistance = 16.2;
            const distanceVariation = Math.random() * 3; // 0 to 3 units variation
            const cloudDistance = baseDistance + distanceVariation;

            // Random position on sphere around planet
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            cloud.position.x = cloudDistance * Math.sin(phi) * Math.cos(theta);
            cloud.position.y = cloudDistance * Math.sin(phi) * Math.sin(theta);
            cloud.position.z = cloudDistance * Math.cos(phi);

            // Look at planet center
            cloud.lookAt(0, 0, 0);

            // Random scale for variety (smaller clouds farther away)
            const distanceFactor = (cloudDistance - baseDistance) / 3; // 0 to 1
            const baseScale = 0.5 + Math.random() * 0.8;
            const scale = baseScale * (1 - distanceFactor * 0.3); // Farther clouds slightly smaller
            cloud.scale.set(scale, scale, scale);

            // Store animation data
            cloud.userData.cloudDistance = cloudDistance; // Store individual distance
            cloud.userData.rotationSpeed = (Math.random() - 0.5) * 0.001; // Slow rotation
            cloud.userData.floatOffset = Math.random() * Math.PI * 2; // Random start phase
            cloud.userData.floatSpeed = 0.0005 + Math.random() * 0.0005;
            cloud.userData.orbitSpeed = 0.00005 + Math.random() * 0.00005; // Clouds drift around planet
            cloud.userData.orbitAxis = new THREE.Vector3(
                Math.random() - 0.5,
                Math.random() - 0.5,
                Math.random() - 0.5
            ).normalize();

            planetGroup.add(cloud);
            clouds.push(cloud);
        }

        // Sun
        const sunDistance = 50;
        const sunRadius = 5;
        const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffdd,
            fog: false
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(10, 10, 10).normalize().multiplyScalar(sunDistance);
        planetGroup.add(sun);

        const sunGlowGeometry = new THREE.SphereGeometry(sunRadius * 1.6, 32, 32);
        const sunGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0xffdd99,
            transparent: true,
            opacity: 0.5,
            fog: false
        });
        const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
        sunGlow.position.copy(sun.position);
        planetGroup.add(sunGlow);

        const sunGlow2Geometry = new THREE.SphereGeometry(sunRadius * 2.2, 32, 32);
        const sunGlow2Material = new THREE.MeshBasicMaterial({
            color: 0xffbb66,
            transparent: true,
            opacity: 0.25,
            fog: false
        });
        const sunGlow2 = new THREE.Mesh(sunGlow2Geometry, sunGlow2Material);
        sunGlow2.position.copy(sun.position);
        planetGroup.add(sunGlow2);

        // Moon
        const moonDistance = 40;
        const moonRadius = 3;
        const moonGeometry = new THREE.SphereGeometry(moonRadius, 32, 32);
        const moonMaterial = new THREE.MeshBasicMaterial({
            color: 0xeeeeff,
            fog: false
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        const sunDirection = new THREE.Vector3(10, 10, 10).normalize();
        moon.position.copy(sunDirection).multiplyScalar(-moonDistance);
        planetGroup.add(moon);

        const moonGlowGeometry = new THREE.SphereGeometry(moonRadius * 1.5, 32, 32);
        const moonGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0xccddff,
            transparent: true,
            opacity: 0.4,
            fog: false
        });
        const moonGlow = new THREE.Mesh(moonGlowGeometry, moonGlowMaterial);
        moonGlow.position.copy(moon.position);
        planetGroup.add(moonGlow);

        const moonLight = new THREE.PointLight(0xaabbdd, 1.0, 100); // Increased from 0.8 to 1.5
        moonLight.position.copy(moon.position);
        planetGroup.add(moonLight);

        const moonDirectionalLight = new THREE.DirectionalLight(0x8899cc, 0.3); // Increased from 0.25 to 0.6 for visible shadows
        moonDirectionalLight.position.copy(moon.position);
        moonDirectionalLight.castShadow = true; // Enable moon shadows
        moonDirectionalLight.shadow.camera.left = -30;
        moonDirectionalLight.shadow.camera.right = 30;
        moonDirectionalLight.shadow.camera.top = 30;
        moonDirectionalLight.shadow.camera.bottom = -30;
        moonDirectionalLight.shadow.camera.near = 0.5;
        moonDirectionalLight.shadow.camera.far = 150;
        moonDirectionalLight.shadow.mapSize.width = 4096; // Lower res than sun for performance
        moonDirectionalLight.shadow.mapSize.height = 4096;
        moonDirectionalLight.shadow.bias = -0.0001;
        moonDirectionalLight.shadow.normalBias = 0.02;
        moonDirectionalLight.shadow.radius = 3; // Softer shadows for moonlight
        planetGroup.add(moonDirectionalLight);

        // Cloud system
        const cloudGroup = new THREE.Group();
        planetGroup.add(cloudGroup);

        const cloudAnimations = [];
        const rainClouds = [];

        // Camera setup
        const cameraDistanceIdle = 1.2;      // Camera distance when idle (closer)
        const cameraDistanceWalking = 1.7;   // Camera distance when walking (zoomed out more)
        const cameraHeight = 1.0; // Camera vertical position
        let currentCameraDistance = cameraDistanceIdle;

        // Camera sway variables - adjust these to tune the effect
        let cameraShakeOffset = new THREE.Vector3(0, 0, 0);
        const cameraSwayIntensity = 0.003;  // Overall sway amount (increase for more movement)
        const cameraSwaySpeed = 25.0;        // Waddle rhythm speed (higher = faster sway)
        const swaySideAmount = 1;         // Side-to-side intensity multiplier
        const swayBobAmount = 0.4;          // Up-down bob intensity multiplier
        const swayRockAmount = 0;         // Forward-back rock intensity multiplier

        // Movement acceleration
        let currentMoveSpeed = 0.0;
        const maxMoveSpeed = 0.125;
        const moveAcceleration = 0.8; // Speed ramping per second
        const moveDeceleration = 1.5; // Faster stop

        camera.position.set(0, spawnHeight + cameraHeight, -cameraDistanceIdle);
        camera.lookAt(0, spawnHeight, 0);

        // Input handling
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            space: false,
            shift: false
        };

        // Physics
        const physics = {
            velocity: new THREE.Vector3(0, 0, 0),
            gravity: 20.0,
            isGrounded: false,
            jumpForce: 5.0,
            characterRadius: 0.1,
            jumpCharging: false,
            jumpChargeTime: 0
        };

        const raycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);

        let introActive = true;

        // Mouse controls for bird's eye camera
        document.addEventListener('mousedown', (e) => {
            // Check if clicking on the escape menu or its children
            const escapeMenu = document.getElementById('escape-menu');
            const isMenuOpen = escapeMenu.classList.contains('visible');
            const clickedOnMenu = escapeMenu.contains(e.target);

            if (e.button === 0 && detachedCamera && !introActive && !(isMenuOpen && clickedOnMenu)) {
                // Left mouse button for dragging in bird's eye view (but not when menu is open and clicked)
                e.preventDefault();
                isDragging = true;
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 0 && detachedCamera) {
                isDragging = false;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging && detachedCamera && !introActive) {
                // Rotate the planet independently in bird's eye view
                const rotateSpeed = 0.005;

                // Create rotation quaternions (both reversed for natural drag feel)
                const deltaYaw = new THREE.Quaternion();
                deltaYaw.setFromAxisAngle(new THREE.Vector3(0, 1, 0), e.movementX * rotateSpeed);

                const deltaPitch = new THREE.Quaternion();
                deltaPitch.setFromAxisAngle(new THREE.Vector3(1, 0, 0), e.movementY * rotateSpeed);

                // Apply rotations to bird's eye rotation
                birdEyeRotation.multiplyQuaternions(deltaYaw, birdEyeRotation);
                birdEyeRotation.multiplyQuaternions(deltaPitch, birdEyeRotation);
            }
        });

        // Scroll wheel for zoom in bird's eye view OR FOV adjustment in normal view
        document.addEventListener('wheel', (e) => {
            if (!introActive) {
                e.preventDefault();
                if (detachedCamera) {
                    // Bird's eye view - zoom distance
                    const zoomSpeed = 0.02; // Smaller jumps for finer control
                    birdEyeDistance += e.deltaY * zoomSpeed;
                    birdEyeDistance = Math.max(8, Math.min(50, birdEyeDistance)); // Zoom range from 8 to 50 units (closer minimum)
                } else {
                    // Normal player view - adjust FOV
                    const fovSpeed = 0.05;
                    camera.fov += e.deltaY * fovSpeed;
                    camera.fov = Math.max(40, Math.min(100, camera.fov)); // FOV range from 40 to 100
                    camera.updateProjectionMatrix();
                }
            }
        }, { passive: false });

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            if (e.key === 'Enter' && introActive) {
                introActive = false;
                document.getElementById('intro-screen').classList.add('fade-out');
                setTimeout(() => {
                    document.getElementById('intro-screen').style.display = 'none';
                }, 1000);
                return;
            }

            // Toggle escape menu with 'Escape' key
            if (e.key === 'Escape' && !introActive) {
                const menu = document.getElementById('escape-menu');
                const overlay = document.getElementById('menu-overlay');

                if (menu.classList.contains('visible')) {
                    // Close menu
                    menu.classList.remove('visible');
                    overlay.classList.remove('visible');
                } else {
                    // Open menu
                    menu.classList.add('visible');
                    overlay.classList.add('visible');

                    // Update menu UI to reflect current state
                    performanceManager.updateMenuUI();
                }
                return;
            }

            // Toggle bird's eye view with 'F' key
            if (key === 'f' && !introActive) {
                if (!detachedCamera) {
                    // Enter bird's eye view - save current state
                    detachedCamera = true;

                    // Save planet rotation, character rotation, and position
                    savedPlanetRotation.copy(planetGroup.quaternion);
                    savedCharacterRotation = characterRotation;
                    savedCharacterPosition.copy(characterGroup.position);

                    // Start bird's eye rotation from current planet rotation
                    birdEyeRotation.copy(planetGroup.quaternion);

                    // Hide character
                    characterGroup.visible = false;

                    document.getElementById('camera-mode-text').textContent = 'Bird\'s Eye View - Left Click & Drag to Rotate, F: Return to Player';
                    console.log('Bird\'s eye view activated - state saved');
                } else {
                    // Return to player view
                    detachedCamera = false;
                    isDragging = false;

                    // Restore saved state
                    planetGroup.quaternion.copy(savedPlanetRotation);
                    characterRotation = savedCharacterRotation;
                    characterGroup.position.copy(savedCharacterPosition);
                    characterGroup.rotation.y = characterRotation;

                    // Show character again
                    characterGroup.visible = true;

                    document.getElementById('camera-mode-text').textContent = 'Walk around the planet!';
                    console.log('Returned to player-locked camera - state restored');
                }
            }

            // Reset to spawn with 'X' key
            if (key === 'x' && !introActive) {
                // Use stored spawn position if available, otherwise use default
                const resetY = window.initialSpawnY || spawnHeight;
                characterGroup.position.set(0, resetY, 0);
                characterRotation = Math.PI;
                characterGroup.rotation.y = characterRotation;
                physics.velocity.set(0, 0, 0);
                physics.isGrounded = false;

                // Reset planet rotation to initial spawn state
                if (window.initialSpawnRotation) {
                    planetGroup.quaternion.copy(window.initialSpawnRotation);
                } else {
                    planetGroup.quaternion.set(0, 0, 0, 1);
                }

                console.log('Character reset to spawn position');
            }

            if (key in keys && !introActive) {
                keys[key] = true;
            }
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                keys.shift = true;
            }

            if (e.code === 'Space' && !introActive && physics.isGrounded && !physics.jumpCharging) {
                // Start jump charge-up
                physics.jumpCharging = true;
                physics.jumpChargeTime = 0;
                animationState.isJumping = true;

                // Play jump animation (charge-up) if available
                if (jumpAction) {
                    jumpAction.reset();
                    jumpAction.play();
                }
            }

            // Quality controls (P key to toggle FPS display, Q to cycle quality manually)
            if (key === 'p') {
                performanceManager.showFPS = !performanceManager.showFPS;
                const indicator = document.getElementById('quality-indicator');
                if (performanceManager.showFPS) {
                    indicator.style.display = 'block';
                } else {
                    indicator.style.display = 'block';
                }
                console.log(`FPS display: ${performanceManager.showFPS ? 'ON' : 'OFF'}`);
            }

            if (key === 'q') {
                performanceManager.isAuto = !performanceManager.isAuto;
                console.log(`Auto quality: ${performanceManager.isAuto ? 'ON' : 'OFF'}`);
                performanceManager.updateUI();
                localStorage.setItem('autoQuality', performanceManager.isAuto);
            }
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) keys[key] = false;
            if (e.code === 'Space') keys.space = false;
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                keys.shift = false;
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Spotify player toggle
        window.toggleSpotify = function(event) {
            event.stopPropagation();
            event.preventDefault();

            const player = document.getElementById('spotify-player');
            const toggle = document.getElementById('spotify-toggle');

            if (player.classList.contains('minimized')) {
                player.classList.remove('minimized');
                toggle.textContent = 'âˆ’';
            } else {
                player.classList.add('minimized');
                toggle.textContent = '+';
            }
        };

        // Escape menu handlers
        document.getElementById('quality-cycle-btn').addEventListener('click', () => {
            performanceManager.cycleQuality();
        });

        // Time of day slider handler
        const timeSlider = document.getElementById('time-slider');
        timeSlider.addEventListener('input', (e) => {
            manualTimeValue = parseInt(e.target.value);
            timeControlEnabled = true;
            // Convert 0-100 to radians (0-2Ï€ for full cycle)
            dayNightAngle = (manualTimeValue / 100) * Math.PI * 2;
            updateTimeButtonText();
        });

        // Time auto/manual toggle
        document.getElementById('time-auto-btn').addEventListener('click', () => {
            timeControlEnabled = !timeControlEnabled;
            updateTimeButtonText();
            if (timeControlEnabled) {
                // Set slider to current angle
                manualTimeValue = Math.round((dayNightAngle / (Math.PI * 2)) * 100);
                timeSlider.value = manualTimeValue;
            }
        });

        function updateTimeButtonText() {
            const btnText = document.getElementById('time-mode-text');
            if (timeControlEnabled) {
                btnText.textContent = 'Manual';
                btnText.parentElement.style.background = 'rgba(139, 195, 74, 0.6)';
            } else {
                btnText.textContent = 'Auto Cycle';
                btnText.parentElement.style.background = 'rgba(139, 195, 74, 0.8)';
            }
        }

        // Close menu when clicking overlay
        document.getElementById('menu-overlay').addEventListener('click', () => {
            document.getElementById('escape-menu').classList.remove('visible');
            document.getElementById('menu-overlay').classList.remove('visible');
        });

        // Animation loop
        const moveSpeed = 0.2; // Movement speed per second (radians)
        const turnSpeed = 2; // Turn speed per second (radians)
        let characterRotation = Math.PI; // Start rotated 180 degrees
        const dayNightSpeed = 0.025; // Day/night cycle speed
        let dayNightAngle = 0;
        let timeControlEnabled = false; // Manual time control vs auto cycle
        let manualTimeValue = 50; // 0-100, where 0=night, 50=day, 100=night again

        // Performance Manager Class - Auto-adjusts quality based on FPS
        class PerformanceManager {
            constructor() {
                this.fpsHistory = [];
                this.fpsHistorySize = 60; // Track last 60 frames (~1 second at 60fps)
                this.currentFPS = 60;
                this.averageFPS = 60;
                this.minFPS = 60;

                this.currentTier = 0; // 0=Ultra, 1=High, 2=Medium, 3=Low, 4=VeryLow, 5=Potato
                this.targetTier = 0;
                this.isAuto = true;

                this.stabilizationTimer = 0;
                this.stabilizationDelay = 3.0; // Wait 3 seconds before changing tiers

                this.showFPS = false;
                this.showQualityIndicator = true;

                // Quality tier definitions
                this.tiers = [
                    { name: 'Ultra', cloudCount: 150, shadowRes: 8192, moonShadowRes: 4096, antialiasing: true, moonEnabled: true, updateEveryNFrames: 1 },
                    { name: 'High', cloudCount: 100, shadowRes: 4096, moonShadowRes: 2048, antialiasing: true, moonEnabled: true, updateEveryNFrames: 1 },
                    { name: 'Medium', cloudCount: 80, shadowRes: 2048, moonShadowRes: 1024, antialiasing: true, moonEnabled: true, updateEveryNFrames: 2 },
                    { name: 'Low', cloudCount: 50, shadowRes: 1024, moonShadowRes: 512, antialiasing: false, moonEnabled: true, updateEveryNFrames: 2 },
                    { name: 'Very Low', cloudCount: 30, shadowRes: 512, moonShadowRes: 0, antialiasing: false, moonEnabled: false, updateEveryNFrames: 3 },
                    { name: 'Potato', cloudCount: 15, shadowRes: 256, moonShadowRes: 0, antialiasing: false, moonEnabled: false, updateEveryNFrames: 4 }
                ];

                this.frameCounter = 0;
                this.lastFrameTime = performance.now();

                // Load saved preferences from localStorage
                const savedAuto = localStorage.getItem('autoQuality');
                if (savedAuto !== null) {
                    this.isAuto = savedAuto === 'true';
                }

                const savedTier = localStorage.getItem('qualityTier');
                if (savedTier !== null && !this.isAuto) {
                    this.currentTier = parseInt(savedTier);
                    this.targetTier = this.currentTier;
                }
            }

            update(deltaTime) {
                // Calculate FPS
                const currentTime = performance.now();
                const frameDelta = (currentTime - this.lastFrameTime) / 1000;
                this.lastFrameTime = currentTime;

                if (frameDelta > 0) {
                    this.currentFPS = 1 / frameDelta;
                    this.fpsHistory.push(this.currentFPS);

                    if (this.fpsHistory.length > this.fpsHistorySize) {
                        this.fpsHistory.shift();
                    }

                    // Calculate average and min FPS
                    this.averageFPS = this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length;
                    this.minFPS = Math.min(...this.fpsHistory);
                }

                // Auto quality adjustment
                if (this.isAuto) {
                    this.autoAdjustQuality(deltaTime);
                }

                this.frameCounter++;
            }

            autoAdjustQuality(deltaTime) {
                // Only adjust after we have enough data
                if (this.fpsHistory.length < 30) return;

                let desiredTier = this.currentTier;

                // Check if we need to downgrade
                if (this.averageFPS < 28) {
                    desiredTier = Math.min(5, this.currentTier + 1); // Move to lower quality
                } else if (this.averageFPS < 35 && this.currentTier < 3) {
                    desiredTier = Math.min(5, this.currentTier + 1);
                }
                // Check if we can upgrade
                else if (this.averageFPS > 55 && this.currentTier > 0) {
                    desiredTier = Math.max(0, this.currentTier - 1); // Move to higher quality
                }

                // If desired tier changed, start stabilization timer
                if (desiredTier !== this.targetTier) {
                    this.targetTier = desiredTier;
                    this.stabilizationTimer = 0;
                } else if (desiredTier !== this.currentTier) {
                    // Same target, accumulate time
                    this.stabilizationTimer += deltaTime;

                    // If stable for long enough, apply change
                    const delay = (desiredTier > this.currentTier) ? 2.0 : 5.0; // Faster downgrade, slower upgrade
                    if (this.stabilizationTimer >= delay) {
                        this.applyTier(desiredTier);
                        this.stabilizationTimer = 0;
                    }
                }
            }

            applyTier(tierIndex) {
                const oldTier = this.currentTier;
                this.currentTier = tierIndex;
                const tier = this.tiers[tierIndex];

                console.log(`Performance: Switching from ${this.tiers[oldTier].name} to ${tier.name} (FPS: ${this.averageFPS.toFixed(1)})`);

                // Apply tier settings
                this.adjustCloudCount(tier.cloudCount);
                this.adjustShadowResolution(tier.shadowRes, tier.moonShadowRes);
                this.adjustMoonLight(tier.moonEnabled);

                // Save to localStorage
                localStorage.setItem('qualityTier', tierIndex);

                // Update UI
                this.updateUI();

                // Show notification
                if (oldTier !== tierIndex) {
                    this.showNotification(`Quality: ${tier.name}`);
                }
            }

            adjustCloudCount(targetCount) {
                const currentCount = clouds.length;

                if (targetCount < currentCount) {
                    // Remove excess clouds
                    const toRemove = currentCount - targetCount;
                    for (let i = 0; i < toRemove; i++) {
                        const cloud = clouds.pop();
                        planetGroup.remove(cloud);
                    }
                } else if (targetCount > currentCount) {
                    // Add more clouds (simplified cloud creation)
                    const toAdd = targetCount - currentCount;
                    for (let i = 0; i < toAdd; i++) {
                        // Simplified cloud creation based on existing code
                        const cloudGroup = new THREE.Group();

                        // Random position on sphere
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI;
                        const cloudDistance = planetRadius + 1.5 + Math.random() * 0.5;

                        const x = cloudDistance * Math.sin(phi) * Math.cos(theta);
                        const y = cloudDistance * Math.cos(phi);
                        const z = cloudDistance * Math.sin(phi) * Math.sin(theta);

                        cloudGroup.position.set(x, y, z);

                        // Create cloud puffs (3-5)
                        const puffCount = 3 + Math.floor(Math.random() * 3);
                        for (let j = 0; j < puffCount; j++) {
                            const puffSize = 0.15 + Math.random() * 0.1;
                            const puffGeometry = new THREE.SphereGeometry(puffSize, 6, 6);
                            const puffMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
                            const puff = new THREE.Mesh(puffGeometry, puffMaterial);

                            puff.position.set(
                                (Math.random() - 0.5) * 0.2,
                                (Math.random() - 0.5) * 0.1,
                                (Math.random() - 0.5) * 0.2
                            );

                            cloudGroup.add(puff);
                        }

                        // Store cloud data
                        cloudGroup.userData.floatSpeed = 0.3 + Math.random() * 0.5;
                        cloudGroup.userData.floatOffset = Math.random() * Math.PI * 2;
                        cloudGroup.userData.cloudDistance = cloudDistance;
                        cloudGroup.userData.rotationSpeed = (Math.random() - 0.5) * 0.002;
                        cloudGroup.userData.orbitSpeed = (Math.random() - 0.5) * 0.0001;
                        cloudGroup.userData.orbitAxis = new THREE.Vector3(
                            Math.random() - 0.5,
                            Math.random() - 0.5,
                            Math.random() - 0.5
                        ).normalize();

                        clouds.push(cloudGroup);
                        planetGroup.add(cloudGroup);
                    }
                }
            }

            adjustShadowResolution(sunRes, moonRes) {
                // Update sun shadow resolution
                sunLight.shadow.mapSize.width = sunRes;
                sunLight.shadow.mapSize.height = sunRes;
                sunLight.shadow.map?.dispose();
                sunLight.shadow.map = null;

                // Preserve original shadow quality settings
                sunLight.shadow.bias = -0.0001;
                sunLight.shadow.normalBias = 0.02;
                sunLight.shadow.radius = 2;

                if (moonRes > 0) {
                    moonDirectionalLight.castShadow = true;
                    moonDirectionalLight.shadow.mapSize.width = moonRes;
                    moonDirectionalLight.shadow.mapSize.height = moonRes;
                    moonDirectionalLight.shadow.map?.dispose();
                    moonDirectionalLight.shadow.map = null;

                    // Preserve moon shadow settings
                    moonDirectionalLight.shadow.bias = -0.0001;
                    moonDirectionalLight.shadow.normalBias = 0.02;
                } else {
                    moonDirectionalLight.castShadow = false;
                }
            }

            adjustMoonLight(enabled) {
                moonLight.visible = enabled;
                moonDirectionalLight.visible = enabled;
                moon.visible = enabled;
                moonGlow.visible = enabled;
            }

            updateUI() {
                const indicator = document.getElementById('quality-indicator');
                if (indicator && this.showQualityIndicator) {
                    const tier = this.tiers[this.currentTier];
                    indicator.textContent = `Quality: ${this.isAuto ? 'Auto (' + tier.name + ')' : tier.name}`;
                }
            }

            showNotification(message) {
                // Could implement a toast notification here
                console.log(`ðŸ“Š ${message}`);
            }

            shouldUpdateThisFrame() {
                const tier = this.tiers[this.currentTier];
                return this.frameCounter % tier.updateEveryNFrames === 0;
            }

            getQualityInfo() {
                return {
                    currentFPS: this.currentFPS.toFixed(1),
                    averageFPS: this.averageFPS.toFixed(1),
                    minFPS: this.minFPS.toFixed(1),
                    tier: this.tiers[this.currentTier].name
                };
            }

            cycleQuality() {
                if (this.isAuto) {
                    // Switch to manual mode at current tier
                    this.isAuto = false;
                    console.log(`Manual quality mode: ${this.tiers[this.currentTier].name}`);
                    // Re-apply current tier to ensure settings are locked
                    this.applyTier(this.currentTier);
                } else {
                    // Cycle through tiers: Ultra -> High -> Medium -> Low -> Very Low -> Potato -> Auto
                    this.currentTier++;
                    if (this.currentTier >= this.tiers.length) {
                        // Back to auto mode - reset to Ultra (tier 0)
                        this.isAuto = true;
                        this.currentTier = 0;
                        // IMPORTANT: Apply Ultra tier settings before switching to auto
                        this.applyTier(0);
                        console.log('Auto quality mode enabled - reset to Ultra');
                    } else {
                        this.applyTier(this.currentTier);
                    }
                }

                // Update menu UI
                this.updateMenuUI();

                // Save preferences
                localStorage.setItem('autoQuality', this.isAuto);
                if (!this.isAuto) {
                    localStorage.setItem('qualityTier', this.currentTier);
                }

                return this.getQualityModeText();
            }

            getQualityModeText() {
                if (this.isAuto) {
                    return { mode: 'Auto', tier: this.tiers[this.currentTier].name };
                } else {
                    return { mode: this.tiers[this.currentTier].name, tier: '' };
                }
            }

            updateMenuUI() {
                const modeText = document.getElementById('quality-mode-text');
                const tierText = document.getElementById('quality-tier-text');

                if (modeText && tierText) {
                    const quality = this.getQualityModeText();
                    modeText.textContent = quality.mode;

                    if (quality.tier) {
                        tierText.textContent = quality.tier;
                        tierText.style.display = 'inline-block';
                    } else {
                        tierText.style.display = 'none';
                    }
                }

                // Also update the quality indicator
                this.updateUI();
            }
        }

        // Initialize performance manager
        const performanceManager = new PerformanceManager();

        // Build collision meshes array once (performance optimization)
        let collisionMeshes = [];
        function buildCollisionMeshes() {
            collisionMeshes = [];
            planetGroup.traverse((child) => {
                if (child.isMesh) {
                    const name = child.name.toLowerCase();
                    if (!name.includes('grass') && !name.includes('pebble')) {
                        collisionMeshes.push(child);
                    }
                }
            });
        }

        // Physics update function with swept collision detection
        function updatePhysics(dt) {
            if (introActive) return;

            // Apply gravity
            physics.velocity.y -= physics.gravity * dt;

            // Calculate movement delta
            const movementDelta = physics.velocity.y * dt;
            const currentY = characterGroup.position.y;
            const newY = currentY + movementDelta;

            // Swept collision detection: raycast along movement path
            const rayOrigin = new THREE.Vector3(
                characterGroup.position.x,
                currentY,
                characterGroup.position.z
            );

            // If moving down, cast ray along movement path
            if (movementDelta < 0) {
                const movementDistance = Math.abs(movementDelta);
                raycaster.set(rayOrigin, downVector);
                raycaster.far = movementDistance + 1.0; // Look ahead of movement

                const intersects = raycaster.intersectObjects(collisionMeshes, false);

                if (intersects.length > 0) {
                    const groundY = intersects[0].point.y;
                    const groundOffset = 0.03;
                    const targetY = groundY + groundOffset;
                    const distanceToGround = currentY - groundY;

                    // Dynamic tolerance based on velocity (prevents tunneling)
                    const velocityFactor = Math.abs(physics.velocity.y);
                    const groundTolerance = 0.1 + (velocityFactor * 0.05);

                    if (distanceToGround <= groundTolerance && physics.velocity.y <= 0) {
                        // Snap to ground
                        characterGroup.position.y = targetY;
                        physics.velocity.y = 0;
                        physics.isGrounded = true;
                    } else if (newY <= groundY + groundOffset) {
                        // About to clip through - snap to ground instead
                        characterGroup.position.y = targetY;
                        physics.velocity.y = 0;
                        physics.isGrounded = true;
                    } else {
                        // Free fall
                        characterGroup.position.y = newY;
                        physics.isGrounded = false;
                    }
                } else {
                    // No ground detected
                    characterGroup.position.y = newY;
                    physics.isGrounded = false;
                }
            } else {
                // Moving up (jumping) - no collision check needed
                characterGroup.position.y = newY;
                physics.isGrounded = false;
            }

            // Safety check: if somehow below ground, teleport above
            raycaster.set(rayOrigin, downVector);
            raycaster.far = 50;
            const safetyCheck = raycaster.intersectObjects(collisionMeshes, false);
            if (safetyCheck.length > 0) {
                const groundY = safetyCheck[0].point.y;
                if (characterGroup.position.y < groundY) {
                    console.warn('Character clipped through ground - correcting position');
                    characterGroup.position.y = groundY + 0.5; // Teleport above ground
                    physics.velocity.y = 0;
                    physics.isGrounded = true;
                }
            }
        }

        const clock = new THREE.Clock();

        // Fixed timestep physics accumulator
        const FIXED_TIMESTEP = 1/60; // 60 FPS physics rate
        let physicsAccumulator = 0;

        function animate() {
            requestAnimationFrame(animate);

            // Clamp deltaTime to prevent huge physics jumps during lag
            let deltaTime = clock.getDelta();
            deltaTime = Math.min(deltaTime, 0.1); // Cap at 100ms (10 FPS minimum)
            const time = clock.getElapsedTime();

            // Update performance manager
            performanceManager.update(deltaTime);

            // Update animation mixer
            if (mixer && characterLoaded) {
                mixer.update(deltaTime);

                // Check if jump animation finished and character is grounded
                if (animationState.isJumping && physics.isGrounded) {
                    animationState.isJumping = false;
                }

                // Handle jump animation (highest priority)
                if (jumpAction && animationState.isJumping) {
                    if (!jumpAction.isRunning()) {
                        // Jump animation takes priority, fade out others
                        if (walkAction && walkAction.isRunning()) walkAction.fadeOut(0.1);
                        if (idleAction && idleAction.isRunning()) idleAction.fadeOut(0.1);
                    }
                }
                // Handle walk/idle transitions (when not jumping)
                else if (walkAction && idleAction) {
                    if (animationState.isWalking) {
                        // Switch to walk
                        if (idleAction.isRunning() && !walkAction.isRunning()) {
                            idleAction.fadeOut(0.2);
                            walkAction.reset().fadeIn(0.2).play();
                        }
                    } else {
                        // Switch to idle
                        if (walkAction.isRunning() && !idleAction.isRunning()) {
                            walkAction.fadeOut(0.2);
                            idleAction.reset().fadeIn(0.2).play();
                        }
                    }
                } else if (walkAction) {
                    // Only walk animation available
                    if (animationState.isWalking) {
                        if (!walkAction.isRunning()) {
                            walkAction.play();
                        }
                    } else {
                        if (walkAction.isRunning()) {
                            walkAction.stop();
                        }
                    }
                }
            }

            // Day/night cycle (only auto-increment if not manually controlled)
            if (!timeControlEnabled) {
                dayNightAngle += dayNightSpeed * deltaTime;
            }

            const sunRotationAxis = new THREE.Vector3(1, 0, 0);
            const sunBasePosition = new THREE.Vector3(10, 10, 10).normalize().multiplyScalar(sunDistance);
            sun.position.copy(sunBasePosition);
            sun.position.applyAxisAngle(sunRotationAxis, dayNightAngle);
            sunGlow.position.copy(sun.position);
            sunGlow2.position.copy(sun.position);
            sunLight.position.copy(sun.position);

            sunLight.target.position.set(0, 0, 0);
            sunLight.target.updateMatrixWorld();

            moon.position.copy(sun.position).multiplyScalar(-1);
            moonGlow.position.copy(moon.position);
            moonLight.position.copy(moon.position);
            moonDirectionalLight.position.copy(moon.position);

            moonDirectionalLight.target.position.set(0, 0, 0);
            moonDirectionalLight.target.updateMatrixWorld();

            // Update atmosphere shader with sun direction
            const sunWorldPos = new THREE.Vector3();
            sun.getWorldPosition(sunWorldPos);
            // Normalize to get direction from planet center (0,0,0) to sun
            const sunDir = sunWorldPos.clone().sub(new THREE.Vector3(0, 0, 0)).normalize();
            atmosphereMaterial.uniforms.sunDirection.value.copy(sunDir);

            // Fade stars based on sun position (day/night)
            // When sun is above horizon (y > 0), fade out stars
            const sunY = sun.position.y;
            const dayNightTransition = Math.max(0, Math.min(1, (sunY + 10) / 20)); // Smooth transition

            // Animate low poly clouds (with performance throttling)
            if (performanceManager.shouldUpdateThisFrame()) {
                clouds.forEach(cloud => {
                    // Store the original direction if not already stored
                    if (!cloud.userData.baseDirection) {
                        cloud.userData.baseDirection = cloud.position.clone().normalize();
                    }

                    // Gentle floating motion - only adjust the distance, keep the direction
                    const floatAmount = Math.sin(time * cloud.userData.floatSpeed + cloud.userData.floatOffset) * 0.3;
                    const newDistance = cloud.userData.cloudDistance + floatAmount;

                    // Update position while maintaining the base direction
                    cloud.position.copy(cloud.userData.baseDirection).multiplyScalar(newDistance);

                    // Orbital drift - slowly rotate the base direction
                    cloud.userData.baseDirection.applyAxisAngle(cloud.userData.orbitAxis, cloud.userData.orbitSpeed);

                    // Slow rotation of the cloud itself
                    cloud.rotation.y += cloud.userData.rotationSpeed;

                    // Hemisphere-based lighting
                    // Get cloud's world position (not local to planetGroup)
                    const cloudWorldPos = new THREE.Vector3();
                    cloud.getWorldPosition(cloudWorldPos);
                    const cloudDir = cloudWorldPos.clone().normalize();

                    // Check if cloud is on day side or night side
                    // Dot product: positive = day side, negative = night side
                    const sunAlignment = cloudDir.dot(sunDir);

                    let cloudBrightness;
                    if (sunAlignment > 0) {
                        // Day hemisphere - cloud is on sun-facing side
                        // Bright white with subtle variation based on angle
                        const lightingIntensity = Math.pow(sunAlignment, 0.3); // Softer falloff
                        cloudBrightness = 0.7 + lightingIntensity * 0.3; // Range: 0.7 to 1.0
                    } else {
                        // Night hemisphere - cloud is on dark side
                        cloudBrightness = 0.05; // Very dark, barely visible
                    }

                    // Update cloud color
                    cloud.children.forEach(puff => {
                        puff.material.color.setRGB(cloudBrightness, cloudBrightness, cloudBrightness);
                    });
                });
            }

            starsMaterial.opacity = 1.0 - dayNightTransition; // 0 during day, 1 during night

            // Gameplay
            if (!introActive) {
                // Handle jump charge-up delay
                if (physics.jumpCharging) {
                    physics.jumpChargeTime += deltaTime;
                    const jumpChargeDelay = 0.3; // 300ms charge-up delay

                    if (physics.jumpChargeTime >= jumpChargeDelay) {
                        // Execute the jump after charge-up
                        physics.velocity.y = physics.jumpForce;
                        physics.isGrounded = false;
                        physics.jumpCharging = false;
                    }
                }

                // Fixed timestep physics accumulator (prevents frame-rate dependent physics)
                physicsAccumulator += deltaTime;
                while (physicsAccumulator >= FIXED_TIMESTEP) {
                    updatePhysics(FIXED_TIMESTEP);
                    physicsAccumulator -= FIXED_TIMESTEP;
                }

                document.getElementById('coordinates').textContent =
                    `Position: (${characterGroup.position.x.toFixed(2)}, ${characterGroup.position.y.toFixed(2)}, ${characterGroup.position.z.toFixed(2)})`;

                characterGroup.position.x = 0;
                characterGroup.position.z = 0;

                const isTurning = keys.a || keys.d;

                if (keys.a) {
                    characterRotation += turnSpeed * deltaTime;
                }
                if (keys.d) {
                    characterRotation -= turnSpeed * deltaTime;
                }

                characterGroup.rotation.y = characterRotation;

                if (keys.w || keys.s || isTurning) {
                    animationState.isWalking = true;
                } else {
                    animationState.isWalking = false;
                }

                if (keys.w || keys.s) {
                    currentMoveSpeed = Math.min(currentMoveSpeed + moveAcceleration * deltaTime, maxMoveSpeed);
                } else {
                    currentMoveSpeed = Math.max(currentMoveSpeed - moveDeceleration * deltaTime, 0);
                }

                if (currentMoveSpeed > 0 && (keys.w || keys.s) && !detachedCamera) {
                    const direction = keys.w ? -1 : 1;

                    const forwardWorld = new THREE.Vector3(
                        Math.sin(characterRotation),
                        0,
                        Math.cos(characterRotation)
                    );

                    const rotationAxis = new THREE.Vector3().crossVectors(
                        new THREE.Vector3(0, 1, 0),
                        forwardWorld
                    ).normalize();

                    const rotation = new THREE.Quaternion();
                    rotation.setFromAxisAngle(rotationAxis, direction * currentMoveSpeed * deltaTime);

                    let collision = false;

                    const forwardRayOrigin = new THREE.Vector3(0, characterGroup.position.y, 0);
                    const forwardDirection = new THREE.Vector3(
                        -Math.sin(characterRotation) * direction,
                        0,
                        -Math.cos(characterRotation) * direction
                    );

                    const forwardRaycaster = new THREE.Raycaster(forwardRayOrigin, forwardDirection, 0, 0.2);
                    const forwardIntersects = forwardRaycaster.intersectObjects(collisionMeshes, false);

                    if (forwardIntersects.length > 0) {
                        const obstacleHeight = forwardIntersects[0].point.y;
                        const obstacleDistance = forwardIntersects[0].distance;
                        const stepHeight = obstacleHeight - (characterGroup.position.y - characterHeight);

                        if (stepHeight > 0.05 || obstacleDistance < 0.15) {
                            collision = true;
                        }
                    }

                    if (!collision) {
                        planetGroup.quaternion.multiplyQuaternions(rotation, planetGroup.quaternion);
                    }
                }

                // Camera update based on mode
                if (detachedCamera) {
                    // Bird's eye view - camera above the world with a slight tilt
                    // Apply independent bird's eye rotation to planet
                    planetGroup.quaternion.copy(birdEyeRotation);

                    // Position camera above the origin (world center) with tilt
                    const cameraHeight = birdEyeDistance * Math.cos(birdEyeTilt);
                    const cameraHorizontalOffset = birdEyeDistance * Math.sin(birdEyeTilt);

                    camera.position.set(0, cameraHeight, cameraHorizontalOffset);
                    camera.lookAt(0, 0, 0); // Look at world center
                } else {
                    // Normal player-locked camera mode - update camera position
                    const targetCameraDistance = (keys.w || keys.s) ? cameraDistanceWalking : cameraDistanceIdle;
                    const lerpFactor = 0.025;
                    currentCameraDistance = currentCameraDistance + (targetCameraDistance - currentCameraDistance) * lerpFactor;

                    // Update camera sway (natural walking motion)
                    if (animationState.isWalking && currentMoveSpeed > 0) {
                        const swayIntensity = (currentMoveSpeed / maxMoveSpeed) * cameraSwayIntensity;
                        const waddlePhase = time * cameraSwaySpeed;

                        cameraShakeOffset.x = Math.sin(waddlePhase) * swayIntensity * swaySideAmount;
                        cameraShakeOffset.y = (1 - Math.cos(waddlePhase * 2)) * swayIntensity * swayBobAmount;
                        cameraShakeOffset.z = Math.sin(waddlePhase * 0.5) * swayIntensity * swayRockAmount;
                    } else {
                        cameraShakeOffset.multiplyScalar(0.85);
                    }

                    // Update camera
                    const cameraOffsetLocal = new THREE.Vector3(0, cameraHeight, -currentCameraDistance);
                    const cameraOffsetWorld = cameraOffsetLocal.clone();
                    cameraOffsetWorld.applyAxisAngle(new THREE.Vector3(0, 1, 0), characterRotation);

                    camera.position.copy(characterGroup.position).add(cameraOffsetWorld).add(cameraShakeOffset);

                    const lookAtOffset = new THREE.Vector3(0, characterHeight, 1);
                    lookAtOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), characterRotation);
                    const lookAtPoint = characterGroup.position.clone().add(lookAtOffset);
                    camera.lookAt(lookAtPoint);
                }

                // Check proximity to signs and show/hide labels
                const proximityRadius = detachedCamera ? 10.0 : 3.0; // Much larger radius in bird's eye view

                signLabels.forEach(signInfo => {
                    // Get current world position of the sign (accounts for planet rotation)
                    const signWorldPos = new THREE.Vector3();
                    signInfo.mesh.getWorldPosition(signWorldPos);

                    // Calculate distance from camera to sign in world space
                    const distance = camera.position.distanceTo(signWorldPos);

                    // Show label if within radius, hide otherwise
                    if (distance < proximityRadius) {
                        signInfo.labelObject.visible = true;

                        // Scale font size in bird's eye view
                        if (detachedCamera) {
                            signInfo.labelObject.element.style.fontSize = '20px';
                            signInfo.labelObject.element.style.padding = '10px 14px';
                        } else {
                            signInfo.labelObject.element.style.fontSize = '14px';
                            signInfo.labelObject.element.style.padding = '8px 12px';
                        }
                    } else {
                        signInfo.labelObject.visible = false;
                    }
                });
            }

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>