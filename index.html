<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planet Portfolio - Prototype</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
        }
        #coordinates {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            font-family: monospace;
        }
        .sign-label {
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-family: Arial, sans-serif;
            border: 1px solid rgba(255, 255, 255, 0.3);
            pointer-events: none;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>Controls:</strong><br>
        W - Move forward<br>
        S - Move backward<br>
        A - Turn left<br>
        D - Turn right<br>
        SPACE - Jump<br>
        Middle Mouse - Bird's Eye View<br>
        Scroll - Zoom (bird's eye)<br>
        R - Return to player<br>
        <br>
        <span id="camera-mode-text">Walk around the planet!</span>
    </div>

    <div id="coordinates">
        Position: (0, 0, 0)
    </div>
    
    <div id="intro-screen">
        <div id="intro-content">
            <h1>Max's World</h1>
            <p id="enter-prompt">Press ENTER to begin</p>
        </div>
    </div>
    
    <style>
        #intro-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 1s ease-out;
        }
        
        #intro-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        #intro-content {
            text-align: center;
            color: white;
        }
        
        #intro-content h1 {
            font-size: 4em;
            margin-bottom: 30px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 5px;
        }
        
        #enter-prompt {
            font-size: 1.5em;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);
        scene.fog = new THREE.Fog(0x0a0a1a, 20, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // CSS2D Renderer for sign labels
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x808080, 2.5);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
        sunLight.position.set(10, 10, 10);
        sunLight.castShadow = true;
        sunLight.shadow.camera.left = -30;
        sunLight.shadow.camera.right = 30;
        sunLight.shadow.camera.top = 30;
        sunLight.shadow.camera.bottom = -30;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 150;
        sunLight.shadow.mapSize.width = 8192;
        sunLight.shadow.mapSize.height = 8192;
        sunLight.shadow.bias = -0.0005;
        sunLight.shadow.normalBias = 0.01;
        sunLight.shadow.radius = 1;

        // Planet
        const planetRadius = 16;

        const planetGroup = new THREE.Group();
        planetGroup.add(sunLight);
        scene.add(planetGroup);

        // Store sign labels and their world positions for proximity detection
        const signLabels = [];

        // Store spawn cube reference
        let spawnCube = null;

        // Bird's eye camera controls
        let detachedCamera = false;
        let birdEyeDistance = 25; // Distance from origin in bird's eye view
        let birdEyeTilt = Math.PI / 6; // 30 degree tilt from top-down (0 = straight down, PI/2 = horizontal)
        let birdEyeRotation = new THREE.Quaternion(); // Independent rotation for bird's eye view
        let isDragging = false;

        // Saved state for returning from bird's eye view
        let savedPlanetRotation = new THREE.Quaternion();
        let savedCharacterRotation = 0;
        let savedCharacterPosition = new THREE.Vector3();

        // Sign content data
        const signData = {
            'sign1': 'Press enter to teleport back to your crash landing.',
            'sign2': 'These were the base for me to grow my creative interests...',
            'sign3': 'Walk left to read my life story, right for my professional journey.', // second
            'sign4': 'Other interests/hobbies.',
            'sign5': 'This way to see my hobbies/passions.',
            'sign6': 'Then, I started exploring the adirondacks.',
            "sign7": "Welcome to my world. Please, explore what I've created.", // Start sign
            'sign8': 'I was born in Guangzhou, China.', // third
            'sign9': 'We moved to the US. My father had family there.', // left 2
            'sign10': 'At 18, I got accepted to Colorado College.', // left three
            'sign11': 'I am now a junior.',
            'sign12': "I'm currently doing research for a professor at the Colorado School of Mines regarding the stigma around mental health.",
            'sign13': "Here's a list of my project: Super mario A* and Theta* Pathfinder in C, Top-Down Adventure Game in Java, Stock Tracker using Alpaca. (a gallery area)",
            'sign14': 'Dabbling in Cybersecurity: Certification in eJPT, working on the PNPT.',
            'sign15': 'Future projects: TBD',
            'sign16': '1',
            'sign17': '2',
            'sign18': '3',
            'sign19': '4',
            'sign20': 'My love of the outdoors started with kayaking the lakes of NY.',
            'sign21': 'Click the sign to see photography portfolio.',
            'sign22': 'Click the sign to see my videography portfolio.',
            'sign23': 'Thank You for Visiting!'
        };

        // Load the Blender world model
        const planetLoader = new GLTFLoader();
        planetLoader.load('world-only.glb', function(gltf) {
            const planet = gltf.scene;

            planet.traverse((child) => {
                if (child.isMesh) {
                    const name = child.name.toLowerCase();
                    const isGround = name.includes('ground');

                    child.castShadow = !isGround;
                    child.receiveShadow = true;

                    // Log all meshes to help debug spawn detection
                    if (name.includes('spawn')) {
                        console.log(`>>> SPAWN MESH FOUND: "${child.name}" (lowercase: "${name}")`);
                    }

                    // Check if this is the spawn cube (check exact name or contains 'spawn')
                    if (name === 'spawn' || name.includes('spawn')) {
                        spawnCube = child;
                        console.log(`Found spawn cube: "${child.name}" (original: "${child.name}") at local position:`, child.position);
                    }

                    // Check if this is a sign
                    if (child.name.toLowerCase().includes('sign')) {
                        const signName = child.name.toLowerCase();
                        const signText = signData[signName] || `Sign: ${child.name}`;

                        // Create label div
                        const labelDiv = document.createElement('div');
                        labelDiv.className = 'sign-label';
                        labelDiv.textContent = signText;

                        // Create CSS2DObject
                        const label = new CSS2DObject(labelDiv);
                        label.visible = false; // Hidden by default

                        // Get world position of the sign for proximity checking
                        child.updateWorldMatrix(true, false);
                        const signWorldPos = new THREE.Vector3();
                        child.getWorldPosition(signWorldPos);

                        // Position label above the sign in local space
                        // Use a fixed height that works well visually
                        label.position.set(0, -22, 0); // 1.2 units above the sign in local space
                        child.add(label);

                        // Store reference for proximity checking
                        signLabels.push({
                            labelObject: label,
                            mesh: child,
                            worldPos: signWorldPos
                        });

                        console.log(`Created label for ${child.name}: "${signText}"`);
                    }
                }
            });

            planetGroup.add(planet);
            console.log('Blender world model loaded successfully');

            // Rotate planet so spawn cube is at character position (0, y, 0)
            console.log('Checking for spawn cube...', spawnCube ? 'Found!' : 'Not found');
            if (spawnCube) {
                // Get the spawn cube's position within the planet's local coordinate system
                // We need to traverse up to find the position in planet's space
                let spawnLocalPos = new THREE.Vector3();
                spawnCube.getWorldPosition(spawnLocalPos);

                // Convert world position to planet's local space
                const planetWorldToLocal = new THREE.Matrix4();
                planetWorldToLocal.copy(planetGroup.matrixWorld).invert();
                spawnLocalPos.applyMatrix4(planetWorldToLocal);

                console.log(`Spawn cube position in planet space: (${spawnLocalPos.x.toFixed(2)}, ${spawnLocalPos.y.toFixed(2)}, ${spawnLocalPos.z.toFixed(2)})`);

                // Normalize the position to get direction on the sphere surface
                const spawnDirection = spawnLocalPos.clone().normalize();

                // We want this direction to point "up" (0, 1, 0) after rotation
                // Calculate the rotation needed
                const upVector = new THREE.Vector3(0, 1, 0);
                const rotationAxis = new THREE.Vector3().crossVectors(spawnDirection, upVector).normalize();
                const rotationAngle = Math.acos(spawnDirection.dot(upVector));

                console.log(`Rotation angle: ${(rotationAngle * 180 / Math.PI).toFixed(2)} degrees`);
                console.log(`Rotation axis: (${rotationAxis.x.toFixed(2)}, ${rotationAxis.y.toFixed(2)}, ${rotationAxis.z.toFixed(2)})`);

                // Apply the rotation
                const spawnRotation = new THREE.Quaternion();
                spawnRotation.setFromAxisAngle(rotationAxis, rotationAngle);
                planetGroup.quaternion.copy(spawnRotation);

                // Update matrices
                planetGroup.updateMatrixWorld(true);

                // Get spawn position for character height
                spawnCube.geometry.computeBoundingBox();
                const bbox = spawnCube.geometry.boundingBox;
                const cubeHeight = bbox.max.y - bbox.min.y;

                // Character height should be at the planet radius + spawn offset
                const spawnHeight = spawnLocalPos.length();
                characterGroup.position.set(0, spawnHeight + cubeHeight / 2 + 2.0, 0);

                console.log(`Character spawned at height: ${characterGroup.position.y.toFixed(2)}`);
            }
        }, undefined, function(error) {
            console.error('Error loading world model:', error);
        });

        // Character setup
        const characterGroup = new THREE.Group();
        scene.add(characterGroup);

        // Animation mixer and actions
        let mixer = null;
        let walkAction = null;
        let idleAction = null;
        let characterModel = null;
        let characterLoaded = false;

        // Animation state
        const animationState = {
            isWalking: false
        };

        // Load penguin character model
        const characterLoader = new GLTFLoader();
        characterLoader.load('manchot_the_penguin.glb', 
            function(gltf) {
                console.log('Penguin character loaded successfully!');
                characterModel = gltf.scene;
                
                // Scale the penguin to appropriate size
                characterModel.scale.set(0.075, 0.075, 0.075);
                
                // Enable shadows
                characterModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                characterGroup.add(characterModel);
                
                // Setup animation mixer
                if (gltf.animations && gltf.animations.length > 0) {
                    console.log('Found animations:', gltf.animations.map(a => a.name));
                    
                    mixer = new THREE.AnimationMixer(characterModel);
                    
                    // Try to find walk animation
                    const walkAnim = gltf.animations.find(a => 
                        a.name.toLowerCase().includes('walk') || 
                        a.name.toLowerCase().includes('run') ||
                        a.name.toLowerCase().includes('waddle')
                    ) || gltf.animations[0]; // Fallback to first animation
                    
                    // Try to find idle animation
                    const idleAnim = gltf.animations.find(a => 
                        a.name.toLowerCase().includes('idle') || 
                        a.name.toLowerCase().includes('standing')
                    );
                    
                    if (walkAnim) {
                        walkAction = mixer.clipAction(walkAnim);
                        walkAction.setEffectiveTimeScale(1.2); // Speed up animation
                        console.log('Walk animation set:', walkAnim.name);
                    }
                    
                    if (idleAnim) {
                        idleAction = mixer.clipAction(idleAnim);
                        idleAction.play();
                        console.log('Idle animation set:', idleAnim.name);
                    } else if (walkAction) {
                        // If no idle, just stop walk animation when not moving
                        console.log('No idle animation found, using walk animation only');
                    }
                } else {
                    console.warn('No animations found in penguin model');
                }
                
                characterLoaded = true;
                console.log('Penguin character setup complete');
            }, 
            function(progress) {
                console.log('Loading penguin:', (progress.loaded / progress.total * 100).toFixed(2) + '%');
            },
            function(error) {
                console.error('Error loading penguin model:', error);
            }
        );

        // Position character at spawn height
        const characterHeight = 0.075;
        const spawnHeight = 13; // Spawn higher to ensure proper ground detection
        characterGroup.position.set(0, spawnHeight, 0);

        // Stars background
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
        const starsVertices = [];
        for (let i = 0; i < 1000; i++) {
            const x = (Math.random() - 0.5) * 100;
            const y = (Math.random() - 0.5) * 100;
            const z = (Math.random() - 0.5) * 100;
            starsVertices.push(x, y, z);
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        planetGroup.add(stars);

        // Atmosphere
        const atmosphereGeometry = new THREE.SphereGeometry(25, 32, 32);
        const atmosphereMaterial = new THREE.ShaderMaterial({
            uniforms: {
                sunDirection: { value: new THREE.Vector3(1, 1, 1).normalize() },
                dayColor: { value: new THREE.Color(0x87CEEB) },
                nightColor: { value: new THREE.Color(0x000000) },
                horizonColor: { value: new THREE.Color(0xFFB347) }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 sunDirection;
                uniform vec3 dayColor;
                uniform vec3 nightColor;
                uniform vec3 horizonColor;
                varying vec3 vNormal;
                varying vec3 vPosition;

                void main() {
                    vec3 normal = normalize(vPosition);
                    float sunAlignment = dot(normal, sunDirection);
                    float dayStrength = smoothstep(-0.3, 0.3, sunAlignment);
                    float horizonGlow = 1.0 - abs(sunAlignment);
                    horizonGlow = pow(horizonGlow, 3.0) * dayStrength;
                    vec3 skyColor = mix(nightColor, dayColor, dayStrength);
                    skyColor = mix(skyColor, horizonColor, horizonGlow * 0.5);
                    float alpha = dayStrength * 0.9 + 0.1;
                    gl_FragColor = vec4(skyColor, alpha);
                }
            `,
            side: THREE.BackSide,
            transparent: true,
            depthWrite: false
        });
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        scene.add(atmosphere);

        // Sun
        const sunDistance = 50;
        const sunRadius = 5;
        const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffdd,
            fog: false
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.set(10, 10, 10).normalize().multiplyScalar(sunDistance);
        planetGroup.add(sun);

        const sunGlowGeometry = new THREE.SphereGeometry(sunRadius * 1.6, 32, 32);
        const sunGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0xffdd99,
            transparent: true,
            opacity: 0.5,
            fog: false
        });
        const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
        sunGlow.position.copy(sun.position);
        planetGroup.add(sunGlow);

        const sunGlow2Geometry = new THREE.SphereGeometry(sunRadius * 2.2, 32, 32);
        const sunGlow2Material = new THREE.MeshBasicMaterial({
            color: 0xffbb66,
            transparent: true,
            opacity: 0.25,
            fog: false
        });
        const sunGlow2 = new THREE.Mesh(sunGlow2Geometry, sunGlow2Material);
        sunGlow2.position.copy(sun.position);
        planetGroup.add(sunGlow2);

        // Moon
        const moonDistance = 40;
        const moonRadius = 3;
        const moonGeometry = new THREE.SphereGeometry(moonRadius, 32, 32);
        const moonMaterial = new THREE.MeshBasicMaterial({
            color: 0xeeeeff,
            fog: false
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        const sunDirection = new THREE.Vector3(10, 10, 10).normalize();
        moon.position.copy(sunDirection).multiplyScalar(-moonDistance);
        planetGroup.add(moon);

        const moonGlowGeometry = new THREE.SphereGeometry(moonRadius * 1.5, 32, 32);
        const moonGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0xccddff,
            transparent: true,
            opacity: 0.4,
            fog: false
        });
        const moonGlow = new THREE.Mesh(moonGlowGeometry, moonGlowMaterial);
        moonGlow.position.copy(moon.position);
        planetGroup.add(moonGlow);

        const moonLight = new THREE.PointLight(0xaabbdd, 0.8, 100);
        moonLight.position.copy(moon.position);
        planetGroup.add(moonLight);

        const moonDirectionalLight = new THREE.DirectionalLight(0x8899cc, 0.25);
        moonDirectionalLight.position.copy(moon.position);
        planetGroup.add(moonDirectionalLight);

        // Cloud system
        const cloudGroup = new THREE.Group();
        planetGroup.add(cloudGroup);

        const cloudAnimations = [];
        const rainClouds = [];

        // Camera setup
        const cameraDistanceIdle = 1.2;      // Camera distance when idle (closer)
        const cameraDistanceWalking = 1.7;   // Camera distance when walking (zoomed out more)
        const cameraHeight = 1.0; // Camera vertical position
        let currentCameraDistance = cameraDistanceIdle;

        // Camera sway variables - adjust these to tune the effect
        let cameraShakeOffset = new THREE.Vector3(0, 0, 0);
        const cameraSwayIntensity = 0.003;  // Overall sway amount (increase for more movement)
        const cameraSwaySpeed = 25.0;        // Waddle rhythm speed (higher = faster sway)
        const swaySideAmount = 1;         // Side-to-side intensity multiplier
        const swayBobAmount = 0.4;          // Up-down bob intensity multiplier
        const swayRockAmount = 0;         // Forward-back rock intensity multiplier

        // Movement acceleration
        let currentMoveSpeed = 0.0;
        const maxMoveSpeed = 0.2;
        const moveAcceleration = 0.8; // Speed ramping per second
        const moveDeceleration = 1.5; // Faster stop

        camera.position.set(0, spawnHeight + cameraHeight, -cameraDistanceIdle);
        camera.lookAt(0, spawnHeight, 0);

        // Input handling
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            space: false,
            shift: false
        };

        // Physics
        const physics = {
            velocity: new THREE.Vector3(0, 0, 0),
            gravity: 20.0,
            isGrounded: false,
            jumpForce: 5.0,
            characterRadius: 0.1
        };

        const raycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);

        let introActive = true;

        // Mouse controls for bird's eye camera
        document.addEventListener('mousedown', (e) => {
            if (e.button === 1 && !introActive) { // Middle mouse button
                e.preventDefault();

                if (!detachedCamera) {
                    // Toggle to bird's eye view - save current state
                    detachedCamera = true;

                    // Save planet rotation, character rotation, and position
                    savedPlanetRotation.copy(planetGroup.quaternion);
                    savedCharacterRotation = characterRotation;
                    savedCharacterPosition.copy(characterGroup.position);

                    // Start bird's eye rotation from current planet rotation
                    birdEyeRotation.copy(planetGroup.quaternion);

                    // Hide character
                    characterGroup.visible = false;

                    document.getElementById('camera-mode-text').textContent = 'Bird\'s Eye View - Drag to Rotate, R: Return to Player';
                    console.log('Bird\'s eye view activated - state saved');
                } else {
                    // Start dragging
                    isDragging = true;
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 1 && detachedCamera) {
                isDragging = false;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging && detachedCamera && !introActive) {
                // Rotate the planet independently in bird's eye view
                const rotateSpeed = 0.005;

                // Create rotation quaternions (both reversed for natural drag feel)
                const deltaYaw = new THREE.Quaternion();
                deltaYaw.setFromAxisAngle(new THREE.Vector3(0, 1, 0), e.movementX * rotateSpeed);

                const deltaPitch = new THREE.Quaternion();
                deltaPitch.setFromAxisAngle(new THREE.Vector3(1, 0, 0), e.movementY * rotateSpeed);

                // Apply rotations to bird's eye rotation
                birdEyeRotation.multiplyQuaternions(deltaYaw, birdEyeRotation);
                birdEyeRotation.multiplyQuaternions(deltaPitch, birdEyeRotation);
            }
        });

        // Scroll wheel for zoom in/out in bird's eye view
        document.addEventListener('wheel', (e) => {
            if (detachedCamera && !introActive) {
                e.preventDefault();
                const zoomSpeed = 0.02; // Smaller jumps for finer control
                birdEyeDistance += e.deltaY * zoomSpeed;
                birdEyeDistance = Math.max(8, Math.min(50, birdEyeDistance)); // Zoom range from 8 to 50 units (closer minimum)
            }
        }, { passive: false });

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            if (e.key === 'Enter' && introActive) {
                introActive = false;
                document.getElementById('intro-screen').classList.add('fade-out');
                setTimeout(() => {
                    document.getElementById('intro-screen').style.display = 'none';
                }, 1000);
                return;
            }

            // Return to player with 'R' key
            if (key === 'r' && !introActive && detachedCamera) {
                detachedCamera = false;

                // Restore saved state
                planetGroup.quaternion.copy(savedPlanetRotation);
                characterRotation = savedCharacterRotation;
                characterGroup.position.copy(savedCharacterPosition);
                characterGroup.rotation.y = characterRotation;

                // Show character again
                characterGroup.visible = true;

                document.getElementById('camera-mode-text').textContent = 'Walk around the planet!';
                console.log('Returned to player-locked camera - state restored');
            }

            if (key in keys && !introActive) {
                keys[key] = true;
            }
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                keys.shift = true;
            }

            if (e.code === 'Space' && !introActive && physics.isGrounded) {
                physics.velocity.y = physics.jumpForce;
                physics.isGrounded = false;
            }
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) keys[key] = false;
            if (e.code === 'Space') keys.space = false;
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                keys.shift = false;
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        const moveSpeed = 0.2; // Movement speed per second (radians)
        const turnSpeed = 2; // Turn speed per second (radians)
        let characterRotation = Math.PI; // Start rotated 180 degrees
        const dayNightSpeed = 0.025; // Day/night cycle speed
        let dayNightAngle = 0;
        
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            const time = clock.getElapsedTime();

            // Update animation mixer
            if (mixer && characterLoaded) {
                mixer.update(deltaTime);

                // Handle walk/idle transitions
                if (walkAction && idleAction) {
                    if (animationState.isWalking) {
                        // Switch to walk
                        if (idleAction.isRunning() && !walkAction.isRunning()) {
                            idleAction.fadeOut(0.2);
                            walkAction.reset().fadeIn(0.2).play();
                        }
                    } else {
                        // Switch to idle
                        if (walkAction.isRunning() && !idleAction.isRunning()) {
                            walkAction.fadeOut(0.2);
                            idleAction.reset().fadeIn(0.2).play();
                        }
                    }
                } else if (walkAction) {
                    // Only walk animation available
                    if (animationState.isWalking) {
                        if (!walkAction.isRunning()) {
                            walkAction.play();
                        }
                    } else {
                        if (walkAction.isRunning()) {
                            walkAction.stop();
                        }
                    }
                }
            }

            // Day/night cycle
            dayNightAngle += dayNightSpeed * deltaTime;

            const sunRotationAxis = new THREE.Vector3(1, 0, 0);
            const sunBasePosition = new THREE.Vector3(10, 10, 10).normalize().multiplyScalar(sunDistance);
            sun.position.copy(sunBasePosition);
            sun.position.applyAxisAngle(sunRotationAxis, dayNightAngle);
            sunGlow.position.copy(sun.position);
            sunGlow2.position.copy(sun.position);
            sunLight.position.copy(sun.position);

            sunLight.target.position.set(0, 0, 0);
            sunLight.target.updateMatrixWorld();

            moon.position.copy(sun.position).multiplyScalar(-1);
            moonGlow.position.copy(moon.position);
            moonLight.position.copy(moon.position);
            moonDirectionalLight.position.copy(moon.position);

            moonDirectionalLight.target.position.set(0, 0, 0);
            moonDirectionalLight.target.updateMatrixWorld();

            // Update atmosphere shader with sun direction
            const sunWorldPos = new THREE.Vector3();
            sun.getWorldPosition(sunWorldPos);
            // Normalize to get direction from planet center (0,0,0) to sun
            const sunDir = sunWorldPos.clone().sub(new THREE.Vector3(0, 0, 0)).normalize();
            atmosphereMaterial.uniforms.sunDirection.value.copy(sunDir);

            // Gameplay
            if (!introActive) {
                // Character physics and movement (works in both modes)
                physics.velocity.y -= physics.gravity * deltaTime;
                const newY = characterGroup.position.y + physics.velocity.y * deltaTime;

                const rayOrigin = new THREE.Vector3(
                    characterGroup.position.x,
                    characterGroup.position.y,
                    characterGroup.position.z
                );

                raycaster.set(rayOrigin, downVector);
                raycaster.far = 50;

                const collisionMeshes = [];
                planetGroup.traverse((child) => {
                    if (child.isMesh) {
                        const name = child.name.toLowerCase();
                        if (!name.includes('grass') && !name.includes('pebble')) {
                            collisionMeshes.push(child);
                        }
                    }
                });

                const intersects = raycaster.intersectObjects(collisionMeshes, false);

                if (intersects.length > 0) {
                    const groundY = intersects[0].point.y;
                    const groundOffset = 0.03;
                    const targetY = groundY + groundOffset;
                    const distanceToGround = characterGroup.position.y - groundY;
                    const groundTolerance = 0.1;

                    if (distanceToGround <= groundTolerance && physics.velocity.y <= 0) {
                        characterGroup.position.y = targetY;
                        physics.velocity.y = 0;
                        physics.isGrounded = true;
                    } else {
                        characterGroup.position.y = newY;
                        physics.isGrounded = false;
                    }
                } else {
                    characterGroup.position.y = newY;
                    physics.isGrounded = false;
                }

                document.getElementById('coordinates').textContent =
                    `Position: (${characterGroup.position.x.toFixed(2)}, ${characterGroup.position.y.toFixed(2)}, ${characterGroup.position.z.toFixed(2)})`;

                characterGroup.position.x = 0;
                characterGroup.position.z = 0;

                const isTurning = keys.a || keys.d;

                if (keys.a) {
                    characterRotation += turnSpeed * deltaTime;
                }
                if (keys.d) {
                    characterRotation -= turnSpeed * deltaTime;
                }

                characterGroup.rotation.y = characterRotation;

                if (keys.w || keys.s || isTurning) {
                    animationState.isWalking = true;
                } else {
                    animationState.isWalking = false;
                }

                if (keys.w || keys.s) {
                    currentMoveSpeed = Math.min(currentMoveSpeed + moveAcceleration * deltaTime, maxMoveSpeed);
                } else {
                    currentMoveSpeed = Math.max(currentMoveSpeed - moveDeceleration * deltaTime, 0);
                }

                if (currentMoveSpeed > 0 && (keys.w || keys.s) && !detachedCamera) {
                    const direction = keys.w ? -1 : 1;

                    const forwardWorld = new THREE.Vector3(
                        Math.sin(characterRotation),
                        0,
                        Math.cos(characterRotation)
                    );

                    const rotationAxis = new THREE.Vector3().crossVectors(
                        new THREE.Vector3(0, 1, 0),
                        forwardWorld
                    ).normalize();

                    const rotation = new THREE.Quaternion();
                    rotation.setFromAxisAngle(rotationAxis, direction * currentMoveSpeed * deltaTime);

                    let collision = false;

                    const forwardRayOrigin = new THREE.Vector3(0, characterGroup.position.y, 0);
                    const forwardDirection = new THREE.Vector3(
                        -Math.sin(characterRotation) * direction,
                        0,
                        -Math.cos(characterRotation) * direction
                    );

                    const forwardRaycaster = new THREE.Raycaster(forwardRayOrigin, forwardDirection, 0, 0.2);
                    const forwardIntersects = forwardRaycaster.intersectObjects(collisionMeshes, false);

                    if (forwardIntersects.length > 0) {
                        const obstacleHeight = forwardIntersects[0].point.y;
                        const obstacleDistance = forwardIntersects[0].distance;
                        const stepHeight = obstacleHeight - (characterGroup.position.y - characterHeight);

                        if (stepHeight > 0.05 || obstacleDistance < 0.15) {
                            collision = true;
                        }
                    }

                    if (!collision) {
                        planetGroup.quaternion.multiplyQuaternions(rotation, planetGroup.quaternion);
                    }
                }

                // Camera update based on mode
                if (detachedCamera) {
                    // Bird's eye view - camera above the world with a slight tilt
                    // Apply independent bird's eye rotation to planet
                    planetGroup.quaternion.copy(birdEyeRotation);

                    // Position camera above the origin (world center) with tilt
                    const cameraHeight = birdEyeDistance * Math.cos(birdEyeTilt);
                    const cameraHorizontalOffset = birdEyeDistance * Math.sin(birdEyeTilt);

                    camera.position.set(0, cameraHeight, cameraHorizontalOffset);
                    camera.lookAt(0, 0, 0); // Look at world center
                } else {
                    // Normal player-locked camera mode - update camera position
                    const targetCameraDistance = (keys.w || keys.s) ? cameraDistanceWalking : cameraDistanceIdle;
                    const lerpFactor = 0.025;
                    currentCameraDistance = currentCameraDistance + (targetCameraDistance - currentCameraDistance) * lerpFactor;

                    // Update camera sway (natural walking motion)
                    if (animationState.isWalking && currentMoveSpeed > 0) {
                        const swayIntensity = (currentMoveSpeed / maxMoveSpeed) * cameraSwayIntensity;
                        const waddlePhase = time * cameraSwaySpeed;

                        cameraShakeOffset.x = Math.sin(waddlePhase) * swayIntensity * swaySideAmount;
                        cameraShakeOffset.y = (1 - Math.cos(waddlePhase * 2)) * swayIntensity * swayBobAmount;
                        cameraShakeOffset.z = Math.sin(waddlePhase * 0.5) * swayIntensity * swayRockAmount;
                    } else {
                        cameraShakeOffset.multiplyScalar(0.85);
                    }

                    // Update camera
                    const cameraOffsetLocal = new THREE.Vector3(0, cameraHeight, -currentCameraDistance);
                    const cameraOffsetWorld = cameraOffsetLocal.clone();
                    cameraOffsetWorld.applyAxisAngle(new THREE.Vector3(0, 1, 0), characterRotation);

                    camera.position.copy(characterGroup.position).add(cameraOffsetWorld).add(cameraShakeOffset);

                    const lookAtOffset = new THREE.Vector3(0, characterHeight, 1);
                    lookAtOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), characterRotation);
                    const lookAtPoint = characterGroup.position.clone().add(lookAtOffset);
                    camera.lookAt(lookAtPoint);
                }

                // Check proximity to signs and show/hide labels
                const proximityRadius = detachedCamera ? 6.0 : 3.0; // Much larger radius in bird's eye view

                signLabels.forEach(signInfo => {
                    // Get current world position of the sign (accounts for planet rotation)
                    const signWorldPos = new THREE.Vector3();
                    signInfo.mesh.getWorldPosition(signWorldPos);

                    // Calculate distance from camera to sign in world space
                    const distance = camera.position.distanceTo(signWorldPos);

                    // Show label if within radius, hide otherwise
                    if (distance < proximityRadius) {
                        signInfo.labelObject.visible = true;

                        // Scale font size in bird's eye view
                        if (detachedCamera) {
                            signInfo.labelObject.element.style.fontSize = '16px';
                            signInfo.labelObject.element.style.padding = '10px 14px';
                        } else {
                            signInfo.labelObject.element.style.fontSize = '12px';
                            signInfo.labelObject.element.style.padding = '8px 12px';
                        }
                    } else {
                        signInfo.labelObject.visible = false;
                    }
                });
            }

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>